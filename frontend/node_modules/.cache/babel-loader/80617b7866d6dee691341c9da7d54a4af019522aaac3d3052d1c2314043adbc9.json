{"ast":null,"code":"var _jsxFileName = \"D:\\\\REACT\\\\collaborative-drawing-app\\\\frontend\\\\src\\\\context\\\\WebSocketContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useEffect, useRef, useState, useCallback } from \"react\";\n\n// Context for sharing websocket state and actions across the app\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const WebSocketContext = /*#__PURE__*/createContext(null);\nfunction getToken() {\n  return localStorage.getItem(\"token\");\n}\nclass MessageQueue {\n  constructor() {\n    this.queue = [];\n    this.maxQueueSize = 100;\n  }\n  enqueue(message) {\n    if (this.queue.length >= this.maxQueueSize) {\n      console.warn('Message queue full, dropping oldest message');\n      this.queue.shift();\n    }\n    this.queue.push({\n      message,\n      timestamp: Date.now()\n    });\n  }\n  dequeue() {\n    return this.queue.shift();\n  }\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n  size() {\n    return this.queue.length;\n  }\n  clear() {\n    this.queue = [];\n  }\n  getAllMessages() {\n    return [...this.queue];\n  }\n}\nexport const WebSocketProvider = ({\n  roomId,\n  children\n}) => {\n  _s();\n  const wsRef = useRef(null);\n  const [wsStatus, setWsStatus] = useState(\"disconnected\");\n  const [lastMessage, setLastMessage] = useState(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const messageQueueRef = useRef(new MessageQueue());\n  const maxReconnectAttempts = 5;\n  const baseReconnectDelay = 2000; // 2 seconds base delay\n\n  const getReconnectDelay = attempt => Math.min(baseReconnectDelay * Math.pow(2, attempt), 30000);\n  const flushMessageQueue = () => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      const queueSize = messageQueueRef.current.size();\n      if (queueSize > 0) {\n        console.log(`Flushing ${queueSize} queued messages`);\n        while (!messageQueueRef.current.isEmpty()) {\n          const item = messageQueueRef.current.dequeue();\n          try {\n            wsRef.current.send(item.message);\n          } catch (error) {\n            console.error('Failed to send queued message:', error);\n            break;\n          }\n        }\n      }\n    }\n  };\n  const sendMessage = message => {\n    var _wsRef$current2;\n    const msgString = typeof message === 'string' ? message : JSON.stringify(message);\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      try {\n        wsRef.current.send(msgString);\n      } catch (error) {\n        console.error('Failed to send message, queuing:', error);\n        messageQueueRef.current.enqueue(msgString);\n      }\n    } else {\n      console.log('WebSocket not ready, queuing message');\n      messageQueueRef.current.enqueue(msgString);\n    }\n  };\n  const connect = useCallback(() => {\n    if (!roomId) {\n      console.warn('No roomId provided');\n      return;\n    }\n    const token = getToken();\n    if (!token) {\n      console.warn('No authentication token found');\n      setWsStatus(\"no_auth\");\n      return;\n    }\n\n    // Dynamically determine WebSocket URL based on environment\n    const getWebSocketUrl = () => {\n      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n      const wsProtocol = apiUrl.startsWith('https') ? 'wss' : 'ws';\n      const baseUrl = apiUrl.replace(/^https?:\\/\\//, '');\n      return `${wsProtocol}://${baseUrl}/ws/${roomId}?token=${token}`;\n    };\n    const wsUrl = getWebSocketUrl();\n    console.log(`Connecting to ${wsUrl} (Attempt ${reconnectAttemptsRef.current + 1})`);\n    try {\n      const socket = new WebSocket(wsUrl);\n      wsRef.current = socket;\n      setWsStatus(\"connecting\");\n\n      // --- MAIN ADDITION: listen for incoming messages and update lastMessage ---\n      socket.onmessage = event => {\n        setLastMessage(event.data);\n      };\n      socket.onopen = () => {\n        console.log('WebSocket connected successfully');\n        setWsStatus(\"connected\");\n        reconnectAttemptsRef.current = 0; // Reset on success\n        setTimeout(() => flushMessageQueue(), 100);\n      };\n      socket.onclose = event => {\n        console.log(`WebSocket closed (Code: ${event.code}, Reason: ${event.reason || 'No reason provided'})`);\n        setWsStatus(\"disconnected\");\n        wsRef.current = null;\n        if (reconnectAttemptsRef.current < maxReconnectAttempts) {\n          const delay = getReconnectDelay(reconnectAttemptsRef.current);\n          reconnectAttemptsRef.current += 1;\n          console.log(`Reconnecting in ${delay}ms... (Attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\n          setWsStatus(\"reconnecting\");\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        } else {\n          console.error('Max reconnection attempts reached. Please refresh the page.');\n          setWsStatus(\"error\");\n          messageQueueRef.current.clear();\n        }\n      };\n      socket.onerror = error => {\n        console.error('WebSocket error occurred:', error);\n        setWsStatus(\"error\");\n      };\n    } catch (error) {\n      console.error('Failed to create WebSocket:', error);\n      setWsStatus(\"error\");\n    }\n  }, [roomId]);\n  const reconnect = () => {\n    console.log('Manual reconnection requested');\n    reconnectAttemptsRef.current = 0;\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (wsRef.current) {\n      wsRef.current.close();\n    }\n    connect();\n  };\n  const getQueueStatus = () => ({\n    size: messageQueueRef.current.size(),\n    isEmpty: messageQueueRef.current.isEmpty()\n  });\n  useEffect(() => {\n    connect();\n    return () => {\n      console.log('Cleaning up WebSocket connection');\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      wsRef.current = null;\n      setWsStatus(\"disconnected\");\n    };\n  }, [connect]);\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: {\n      wsRef,\n      wsStatus,\n      sendMessage,\n      reconnect,\n      getQueueStatus,\n      lastMessage // <--- new! always pass this to consumers\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 189,\n    columnNumber: 5\n  }, this);\n};\n_s(WebSocketProvider, \"Hgr9HtPZpBUoDRfSEFtCDrWkERE=\");\n_c = WebSocketProvider;\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","WebSocketContext","getToken","localStorage","getItem","MessageQueue","constructor","queue","maxQueueSize","enqueue","message","length","console","warn","shift","push","timestamp","Date","now","dequeue","isEmpty","size","clear","getAllMessages","WebSocketProvider","roomId","children","_s","wsRef","wsStatus","setWsStatus","lastMessage","setLastMessage","reconnectTimeoutRef","reconnectAttemptsRef","messageQueueRef","maxReconnectAttempts","baseReconnectDelay","getReconnectDelay","attempt","Math","min","pow","flushMessageQueue","_wsRef$current","current","readyState","WebSocket","OPEN","queueSize","log","item","send","error","sendMessage","_wsRef$current2","msgString","JSON","stringify","connect","token","getWebSocketUrl","apiUrl","process","env","REACT_APP_API_URL","wsProtocol","startsWith","baseUrl","replace","wsUrl","socket","onmessage","event","data","onopen","setTimeout","onclose","code","reason","delay","onerror","reconnect","clearTimeout","close","getQueueStatus","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/REACT/collaborative-drawing-app/frontend/src/context/WebSocketContext.js"],"sourcesContent":["import React, { createContext, useEffect, useRef, useState, useCallback } from \"react\";\r\n\r\n// Context for sharing websocket state and actions across the app\r\nexport const WebSocketContext = createContext(null);\r\n\r\nfunction getToken() {\r\n  return localStorage.getItem(\"token\");\r\n}\r\n\r\nclass MessageQueue {\r\n  constructor() {\r\n    this.queue = [];\r\n    this.maxQueueSize = 100;\r\n  }\r\n  enqueue(message) {\r\n    if (this.queue.length >= this.maxQueueSize) {\r\n      console.warn('Message queue full, dropping oldest message');\r\n      this.queue.shift();\r\n    }\r\n    this.queue.push({\r\n      message,\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n  dequeue() {\r\n    return this.queue.shift();\r\n  }\r\n  isEmpty() {\r\n    return this.queue.length === 0;\r\n  }\r\n  size() {\r\n    return this.queue.length;\r\n  }\r\n  clear() {\r\n    this.queue = [];\r\n  }\r\n  getAllMessages() {\r\n    return [...this.queue];\r\n  }\r\n}\r\n\r\nexport const WebSocketProvider = ({ roomId, children }) => {\r\n  const wsRef = useRef(null);\r\n  const [wsStatus, setWsStatus] = useState(\"disconnected\");\r\n  const [lastMessage, setLastMessage] = useState(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const messageQueueRef = useRef(new MessageQueue());\r\n  const maxReconnectAttempts = 5;\r\n  const baseReconnectDelay = 2000; // 2 seconds base delay\r\n\r\n  const getReconnectDelay = (attempt) => (Math.min(baseReconnectDelay * Math.pow(2, attempt), 30000));\r\n\r\n  const flushMessageQueue = () => {\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      const queueSize = messageQueueRef.current.size();\r\n      if (queueSize > 0) {\r\n        console.log(`Flushing ${queueSize} queued messages`);\r\n        while (!messageQueueRef.current.isEmpty()) {\r\n          const item = messageQueueRef.current.dequeue();\r\n          try {\r\n            wsRef.current.send(item.message);\r\n          } catch (error) {\r\n            console.error('Failed to send queued message:', error);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const sendMessage = (message) => {\r\n    const msgString = typeof message === 'string' ? message : JSON.stringify(message);\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      try {\r\n        wsRef.current.send(msgString);\r\n      } catch (error) {\r\n        console.error('Failed to send message, queuing:', error);\r\n        messageQueueRef.current.enqueue(msgString);\r\n      }\r\n    } else {\r\n      console.log('WebSocket not ready, queuing message');\r\n      messageQueueRef.current.enqueue(msgString);\r\n    }\r\n  };\r\n\r\n  const connect = useCallback(() => {\r\n    if (!roomId) {\r\n      console.warn('No roomId provided');\r\n      return;\r\n    }\r\n    const token = getToken();\r\n    if (!token) {\r\n      console.warn('No authentication token found');\r\n      setWsStatus(\"no_auth\");\r\n      return;\r\n    }\r\n\r\n    // Dynamically determine WebSocket URL based on environment\r\n    const getWebSocketUrl = () => {\r\n      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:8000';\r\n      const wsProtocol = apiUrl.startsWith('https') ? 'wss' : 'ws';\r\n      const baseUrl = apiUrl.replace(/^https?:\\/\\//, '');\r\n      return `${wsProtocol}://${baseUrl}/ws/${roomId}?token=${token}`;\r\n    };\r\n\r\n    const wsUrl = getWebSocketUrl();\r\n    console.log(`Connecting to ${wsUrl} (Attempt ${reconnectAttemptsRef.current + 1})`);\r\n\r\n    try {\r\n      const socket = new WebSocket(wsUrl);\r\n      wsRef.current = socket;\r\n      setWsStatus(\"connecting\");\r\n\r\n      // --- MAIN ADDITION: listen for incoming messages and update lastMessage ---\r\n      socket.onmessage = (event) => {\r\n        setLastMessage(event.data);\r\n      };\r\n\r\n      socket.onopen = () => {\r\n        console.log('WebSocket connected successfully');\r\n        setWsStatus(\"connected\");\r\n        reconnectAttemptsRef.current = 0; // Reset on success\r\n        setTimeout(() => flushMessageQueue(), 100);\r\n      };\r\n\r\n      socket.onclose = (event) => {\r\n        console.log(`WebSocket closed (Code: ${event.code}, Reason: ${event.reason || 'No reason provided'})`);\r\n        setWsStatus(\"disconnected\");\r\n        wsRef.current = null;\r\n        if (reconnectAttemptsRef.current < maxReconnectAttempts) {\r\n          const delay = getReconnectDelay(reconnectAttemptsRef.current);\r\n          reconnectAttemptsRef.current += 1;\r\n          console.log(`Reconnecting in ${delay}ms... (Attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\r\n          setWsStatus(\"reconnecting\");\r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, delay);\r\n        } else {\r\n          console.error('Max reconnection attempts reached. Please refresh the page.');\r\n          setWsStatus(\"error\");\r\n          messageQueueRef.current.clear();\r\n        }\r\n      };\r\n\r\n      socket.onerror = (error) => {\r\n        console.error('WebSocket error occurred:', error);\r\n        setWsStatus(\"error\");\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to create WebSocket:', error);\r\n      setWsStatus(\"error\");\r\n    }\r\n  }, [roomId]);\r\n\r\n  const reconnect = () => {\r\n    console.log('Manual reconnection requested');\r\n    reconnectAttemptsRef.current = 0;\r\n    if (reconnectTimeoutRef.current) {\r\n      clearTimeout(reconnectTimeoutRef.current);\r\n    }\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n    }\r\n    connect();\r\n  };\r\n\r\n  const getQueueStatus = () => ({\r\n    size: messageQueueRef.current.size(),\r\n    isEmpty: messageQueueRef.current.isEmpty()\r\n  });\r\n\r\n  useEffect(() => {\r\n    connect();\r\n    return () => {\r\n      console.log('Cleaning up WebSocket connection');\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n      wsRef.current = null;\r\n      setWsStatus(\"disconnected\");\r\n    };\r\n  }, [connect]);\r\n\r\n  return (\r\n    <WebSocketContext.Provider\r\n      value={{\r\n        wsRef,\r\n        wsStatus,\r\n        sendMessage,\r\n        reconnect,\r\n        getQueueStatus,\r\n        lastMessage    // <--- new! always pass this to consumers\r\n      }}\r\n    >\r\n      {children}\r\n    </WebSocketContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}