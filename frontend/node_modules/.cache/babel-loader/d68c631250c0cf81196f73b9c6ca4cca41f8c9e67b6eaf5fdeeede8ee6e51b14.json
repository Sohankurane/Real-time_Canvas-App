{"ast":null,"code":"import React,{createContext,useEffect,useRef,useState,useCallback}from\"react\";// Context for sharing websocket state and actions across the app\nimport{jsx as _jsx}from\"react/jsx-runtime\";export const WebSocketContext=/*#__PURE__*/createContext(null);// Helper to get JWT token from localStorage\nfunction getToken(){return localStorage.getItem(\"token\");}// In-memory message queue for reliable message delivery (disconnect tolerance)\nclass MessageQueue{constructor(){this.queue=[];this.maxQueueSize=100;}enqueue(message){if(this.queue.length>=this.maxQueueSize){console.warn('Message queue full, dropping oldest message');this.queue.shift();}this.queue.push({message,timestamp:Date.now()});}dequeue(){return this.queue.shift();}isEmpty(){return this.queue.length===0;}size(){return this.queue.length;}clear(){this.queue=[];}getAllMessages(){return[...this.queue];}}// Provider component for managing websocket lifecycle and message queue,\n// reconnection, authentication, and context distribution.\nexport const WebSocketProvider=_ref=>{let{roomId,children}=_ref;const wsRef=useRef(null);const[wsStatus,setWsStatus]=useState(\"disconnected\");const reconnectTimeoutRef=useRef(null);const reconnectAttemptsRef=useRef(0);const messageQueueRef=useRef(new MessageQueue());const maxReconnectAttempts=5;const baseReconnectDelay=2000;// 2 seconds base delay\n// Calculate exponential backoff delay for reconnect attempts\nconst getReconnectDelay=attempt=>Math.min(baseReconnectDelay*Math.pow(2,attempt),30000);// max 30 seconds\n// Try to send all queued messages on connection (flush)\nconst flushMessageQueue=()=>{var _wsRef$current;if(((_wsRef$current=wsRef.current)===null||_wsRef$current===void 0?void 0:_wsRef$current.readyState)===WebSocket.OPEN){const queueSize=messageQueueRef.current.size();if(queueSize>0){console.log(\"Flushing \".concat(queueSize,\" queued messages\"));while(!messageQueueRef.current.isEmpty()){const item=messageQueueRef.current.dequeue();try{wsRef.current.send(item.message);}catch(error){console.error('Failed to send queued message:',error);break;}}}}};// Send a message; queue if socket is not open\nconst sendMessage=message=>{var _wsRef$current2;const msgString=typeof message==='string'?message:JSON.stringify(message);if(((_wsRef$current2=wsRef.current)===null||_wsRef$current2===void 0?void 0:_wsRef$current2.readyState)===WebSocket.OPEN){try{wsRef.current.send(msgString);}catch(error){console.error('Failed to send message, queuing:',error);messageQueueRef.current.enqueue(msgString);}}else{console.log('WebSocket not ready, queuing message');messageQueueRef.current.enqueue(msgString);}};// Connects and manages authentication & reconnection.\n// Called automatically and upon reconnect.\nconst connect=useCallback(()=>{if(!roomId){console.warn('No roomId provided');return;}const token=getToken();if(!token){console.warn('No authentication token found');setWsStatus(\"no_auth\");return;}// TODO: Change wsUrl to wss:// when using HTTPS in production/deployment\nconst wsUrl=\"ws://localhost:8000/ws/\".concat(roomId,\"?token=\").concat(token);console.log(\"Connecting to \".concat(wsUrl,\" (Attempt \").concat(reconnectAttemptsRef.current+1,\")\"));try{const socket=new WebSocket(wsUrl);wsRef.current=socket;setWsStatus(\"connecting\");socket.onopen=()=>{console.log('WebSocket connected successfully');setWsStatus(\"connected\");reconnectAttemptsRef.current=0;// Reset on success\nsetTimeout(()=>flushMessageQueue(),100);};socket.onclose=event=>{console.log(\"WebSocket closed (Code: \".concat(event.code,\", Reason: \").concat(event.reason||'No reason provided',\")\"));setWsStatus(\"disconnected\");wsRef.current=null;// Exponential backoff & auto-retry with cap on attempts\nif(reconnectAttemptsRef.current<maxReconnectAttempts){const delay=getReconnectDelay(reconnectAttemptsRef.current);reconnectAttemptsRef.current+=1;console.log(\"Reconnecting in \".concat(delay,\"ms... (Attempt \").concat(reconnectAttemptsRef.current,\"/\").concat(maxReconnectAttempts,\")\"));setWsStatus(\"reconnecting\");reconnectTimeoutRef.current=setTimeout(()=>{connect();},delay);}else{console.error('Max reconnection attempts reached. Please refresh the page.');setWsStatus(\"error\");messageQueueRef.current.clear();}};socket.onerror=error=>{console.error('WebSocket error occurred:',error);setWsStatus(\"error\");};}catch(error){console.error('Failed to create WebSocket:',error);setWsStatus(\"error\");}},[roomId]);// Only change on roomId\n// Manual reconnect for use from UI\nconst reconnect=()=>{console.log('Manual reconnection requested');reconnectAttemptsRef.current=0;if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}if(wsRef.current){wsRef.current.close();}connect();};// Expose message queue size and state\nconst getQueueStatus=()=>({size:messageQueueRef.current.size(),isEmpty:messageQueueRef.current.isEmpty()});// Initiate websocket and cleanup on roomId change or unmount\nuseEffect(()=>{connect();return()=>{console.log('Cleaning up WebSocket connection');if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}if(wsRef.current){wsRef.current.close();}wsRef.current=null;setWsStatus(\"disconnected\");};// Only re-run when connect() reference changes\n},[connect]);// Distribute websocket context:\n// - wsRef: current socket ref\n// - wsStatus: connection status string\n// - sendMessage: send (with queue fallback)\n// - reconnect: manual reconnect callback\n// - getQueueStatus: exposes queue state for UI\nreturn/*#__PURE__*/_jsx(WebSocketContext.Provider,{value:{wsRef,wsStatus,sendMessage,reconnect,getQueueStatus},children:children});};","map":{"version":3,"names":["React","createContext","useEffect","useRef","useState","useCallback","jsx","_jsx","WebSocketContext","getToken","localStorage","getItem","MessageQueue","constructor","queue","maxQueueSize","enqueue","message","length","console","warn","shift","push","timestamp","Date","now","dequeue","isEmpty","size","clear","getAllMessages","WebSocketProvider","_ref","roomId","children","wsRef","wsStatus","setWsStatus","reconnectTimeoutRef","reconnectAttemptsRef","messageQueueRef","maxReconnectAttempts","baseReconnectDelay","getReconnectDelay","attempt","Math","min","pow","flushMessageQueue","_wsRef$current","current","readyState","WebSocket","OPEN","queueSize","log","concat","item","send","error","sendMessage","_wsRef$current2","msgString","JSON","stringify","connect","token","wsUrl","socket","onopen","setTimeout","onclose","event","code","reason","delay","onerror","reconnect","clearTimeout","close","getQueueStatus","Provider","value"],"sources":["D:/REACT/collaborative-drawing-app/frontend/src/context/WebSocketContext.js"],"sourcesContent":["import React, { createContext, useEffect, useRef, useState, useCallback } from \"react\";\r\n\r\n// Context for sharing websocket state and actions across the app\r\nexport const WebSocketContext = createContext(null);\r\n\r\n// Helper to get JWT token from localStorage\r\nfunction getToken() {\r\n  return localStorage.getItem(\"token\");\r\n}\r\n\r\n// In-memory message queue for reliable message delivery (disconnect tolerance)\r\nclass MessageQueue {\r\n  constructor() {\r\n    this.queue = [];\r\n    this.maxQueueSize = 100;\r\n  }\r\n\r\n  enqueue(message) {\r\n    if (this.queue.length >= this.maxQueueSize) {\r\n      console.warn('Message queue full, dropping oldest message');\r\n      this.queue.shift();\r\n    }\r\n    this.queue.push({\r\n      message,\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n\r\n  dequeue() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.queue.length === 0;\r\n  }\r\n\r\n  size() {\r\n    return this.queue.length;\r\n  }\r\n\r\n  clear() {\r\n    this.queue = [];\r\n  }\r\n\r\n  getAllMessages() {\r\n    return [...this.queue];\r\n  }\r\n}\r\n\r\n// Provider component for managing websocket lifecycle and message queue,\r\n// reconnection, authentication, and context distribution.\r\nexport const WebSocketProvider = ({ roomId, children }) => {\r\n  const wsRef = useRef(null);\r\n  const [wsStatus, setWsStatus] = useState(\"disconnected\");\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const messageQueueRef = useRef(new MessageQueue());\r\n  const maxReconnectAttempts = 5;\r\n  const baseReconnectDelay = 2000; // 2 seconds base delay\r\n\r\n  // Calculate exponential backoff delay for reconnect attempts\r\n  const getReconnectDelay = (attempt) => (\r\n    Math.min(baseReconnectDelay * Math.pow(2, attempt), 30000)\r\n  ); // max 30 seconds\r\n\r\n  // Try to send all queued messages on connection (flush)\r\n  const flushMessageQueue = () => {\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      const queueSize = messageQueueRef.current.size();\r\n      if (queueSize > 0) {\r\n        console.log(`Flushing ${queueSize} queued messages`);\r\n        while (!messageQueueRef.current.isEmpty()) {\r\n          const item = messageQueueRef.current.dequeue();\r\n          try {\r\n            wsRef.current.send(item.message);\r\n          } catch (error) {\r\n            console.error('Failed to send queued message:', error);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Send a message; queue if socket is not open\r\n  const sendMessage = (message) => {\r\n    const msgString = typeof message === 'string' ? message : JSON.stringify(message);\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      try {\r\n        wsRef.current.send(msgString);\r\n      } catch (error) {\r\n        console.error('Failed to send message, queuing:', error);\r\n        messageQueueRef.current.enqueue(msgString);\r\n      }\r\n    } else {\r\n      console.log('WebSocket not ready, queuing message');\r\n      messageQueueRef.current.enqueue(msgString);\r\n    }\r\n  };\r\n\r\n  // Connects and manages authentication & reconnection.\r\n  // Called automatically and upon reconnect.\r\n  const connect = useCallback(() => {\r\n    if (!roomId) {\r\n      console.warn('No roomId provided');\r\n      return;\r\n    }\r\n\r\n    const token = getToken();\r\n    if (!token) {\r\n      console.warn('No authentication token found');\r\n      setWsStatus(\"no_auth\");\r\n      return;\r\n    }\r\n\r\n    // TODO: Change wsUrl to wss:// when using HTTPS in production/deployment\r\n    const wsUrl = `ws://localhost:8000/ws/${roomId}?token=${token}`;\r\n    console.log(`Connecting to ${wsUrl} (Attempt ${reconnectAttemptsRef.current + 1})`);\r\n\r\n    try {\r\n      const socket = new WebSocket(wsUrl);\r\n      wsRef.current = socket;\r\n      setWsStatus(\"connecting\");\r\n\r\n      socket.onopen = () => {\r\n        console.log('WebSocket connected successfully');\r\n        setWsStatus(\"connected\");\r\n        reconnectAttemptsRef.current = 0; // Reset on success\r\n        setTimeout(() => flushMessageQueue(), 100);\r\n      };\r\n\r\n      socket.onclose = (event) => {\r\n        console.log(`WebSocket closed (Code: ${event.code}, Reason: ${event.reason || 'No reason provided'})`);\r\n        setWsStatus(\"disconnected\");\r\n        wsRef.current = null;\r\n\r\n        // Exponential backoff & auto-retry with cap on attempts\r\n        if (reconnectAttemptsRef.current < maxReconnectAttempts) {\r\n          const delay = getReconnectDelay(reconnectAttemptsRef.current);\r\n          reconnectAttemptsRef.current += 1;\r\n          console.log(`Reconnecting in ${delay}ms... (Attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\r\n          setWsStatus(\"reconnecting\");\r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, delay);\r\n        } else {\r\n          console.error('Max reconnection attempts reached. Please refresh the page.');\r\n          setWsStatus(\"error\");\r\n          messageQueueRef.current.clear();\r\n        }\r\n      };\r\n\r\n      socket.onerror = (error) => {\r\n        console.error('WebSocket error occurred:', error);\r\n        setWsStatus(\"error\");\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to create WebSocket:', error);\r\n      setWsStatus(\"error\");\r\n    }\r\n  }, [roomId]); // Only change on roomId\r\n\r\n  // Manual reconnect for use from UI\r\n  const reconnect = () => {\r\n    console.log('Manual reconnection requested');\r\n    reconnectAttemptsRef.current = 0;\r\n    if (reconnectTimeoutRef.current) {\r\n      clearTimeout(reconnectTimeoutRef.current);\r\n    }\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n    }\r\n    connect();\r\n  };\r\n\r\n  // Expose message queue size and state\r\n  const getQueueStatus = () => ({\r\n    size: messageQueueRef.current.size(),\r\n    isEmpty: messageQueueRef.current.isEmpty()\r\n  });\r\n\r\n  // Initiate websocket and cleanup on roomId change or unmount\r\n  useEffect(() => {\r\n    connect();\r\n    return () => {\r\n      console.log('Cleaning up WebSocket connection');\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n      wsRef.current = null;\r\n      setWsStatus(\"disconnected\");\r\n    };\r\n    // Only re-run when connect() reference changes\r\n  }, [connect]);\r\n\r\n  // Distribute websocket context:\r\n  // - wsRef: current socket ref\r\n  // - wsStatus: connection status string\r\n  // - sendMessage: send (with queue fallback)\r\n  // - reconnect: manual reconnect callback\r\n  // - getQueueStatus: exposes queue state for UI\r\n  return (\r\n    <WebSocketContext.Provider\r\n      value={{\r\n        wsRef,\r\n        wsStatus,\r\n        sendMessage,\r\n        reconnect,\r\n        getQueueStatus\r\n      }}\r\n    >\r\n      {children}\r\n    </WebSocketContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,SAAS,CAAEC,MAAM,CAAEC,QAAQ,CAAEC,WAAW,KAAQ,OAAO,CAEtF;AAAA,OAAAC,GAAA,IAAAC,IAAA,yBACA,MAAO,MAAM,CAAAC,gBAAgB,cAAGP,aAAa,CAAC,IAAI,CAAC,CAEnD;AACA,QAAS,CAAAQ,QAAQA,CAAA,CAAG,CAClB,MAAO,CAAAC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CACtC,CAEA;AACA,KAAM,CAAAC,YAAa,CACjBC,WAAWA,CAAA,CAAG,CACZ,IAAI,CAACC,KAAK,CAAG,EAAE,CACf,IAAI,CAACC,YAAY,CAAG,GAAG,CACzB,CAEAC,OAAOA,CAACC,OAAO,CAAE,CACf,GAAI,IAAI,CAACH,KAAK,CAACI,MAAM,EAAI,IAAI,CAACH,YAAY,CAAE,CAC1CI,OAAO,CAACC,IAAI,CAAC,6CAA6C,CAAC,CAC3D,IAAI,CAACN,KAAK,CAACO,KAAK,CAAC,CAAC,CACpB,CACA,IAAI,CAACP,KAAK,CAACQ,IAAI,CAAC,CACdL,OAAO,CACPM,SAAS,CAAEC,IAAI,CAACC,GAAG,CAAC,CACtB,CAAC,CAAC,CACJ,CAEAC,OAAOA,CAAA,CAAG,CACR,MAAO,KAAI,CAACZ,KAAK,CAACO,KAAK,CAAC,CAAC,CAC3B,CAEAM,OAAOA,CAAA,CAAG,CACR,MAAO,KAAI,CAACb,KAAK,CAACI,MAAM,GAAK,CAAC,CAChC,CAEAU,IAAIA,CAAA,CAAG,CACL,MAAO,KAAI,CAACd,KAAK,CAACI,MAAM,CAC1B,CAEAW,KAAKA,CAAA,CAAG,CACN,IAAI,CAACf,KAAK,CAAG,EAAE,CACjB,CAEAgB,cAAcA,CAAA,CAAG,CACf,MAAO,CAAC,GAAG,IAAI,CAAChB,KAAK,CAAC,CACxB,CACF,CAEA;AACA;AACA,MAAO,MAAM,CAAAiB,iBAAiB,CAAGC,IAAA,EAA0B,IAAzB,CAAEC,MAAM,CAAEC,QAAS,CAAC,CAAAF,IAAA,CACpD,KAAM,CAAAG,KAAK,CAAGhC,MAAM,CAAC,IAAI,CAAC,CAC1B,KAAM,CAACiC,QAAQ,CAAEC,WAAW,CAAC,CAAGjC,QAAQ,CAAC,cAAc,CAAC,CACxD,KAAM,CAAAkC,mBAAmB,CAAGnC,MAAM,CAAC,IAAI,CAAC,CACxC,KAAM,CAAAoC,oBAAoB,CAAGpC,MAAM,CAAC,CAAC,CAAC,CACtC,KAAM,CAAAqC,eAAe,CAAGrC,MAAM,CAAC,GAAI,CAAAS,YAAY,CAAC,CAAC,CAAC,CAClD,KAAM,CAAA6B,oBAAoB,CAAG,CAAC,CAC9B,KAAM,CAAAC,kBAAkB,CAAG,IAAI,CAAE;AAEjC;AACA,KAAM,CAAAC,iBAAiB,CAAIC,OAAO,EAChCC,IAAI,CAACC,GAAG,CAACJ,kBAAkB,CAAGG,IAAI,CAACE,GAAG,CAAC,CAAC,CAAEH,OAAO,CAAC,CAAE,KAAK,CAC1D,CAAE;AAEH;AACA,KAAM,CAAAI,iBAAiB,CAAGA,CAAA,GAAM,KAAAC,cAAA,CAC9B,GAAI,EAAAA,cAAA,CAAAd,KAAK,CAACe,OAAO,UAAAD,cAAA,iBAAbA,cAAA,CAAeE,UAAU,IAAKC,SAAS,CAACC,IAAI,CAAE,CAChD,KAAM,CAAAC,SAAS,CAAGd,eAAe,CAACU,OAAO,CAACtB,IAAI,CAAC,CAAC,CAChD,GAAI0B,SAAS,CAAG,CAAC,CAAE,CACjBnC,OAAO,CAACoC,GAAG,aAAAC,MAAA,CAAaF,SAAS,oBAAkB,CAAC,CACpD,MAAO,CAACd,eAAe,CAACU,OAAO,CAACvB,OAAO,CAAC,CAAC,CAAE,CACzC,KAAM,CAAA8B,IAAI,CAAGjB,eAAe,CAACU,OAAO,CAACxB,OAAO,CAAC,CAAC,CAC9C,GAAI,CACFS,KAAK,CAACe,OAAO,CAACQ,IAAI,CAACD,IAAI,CAACxC,OAAO,CAAC,CAClC,CAAE,MAAO0C,KAAK,CAAE,CACdxC,OAAO,CAACwC,KAAK,CAAC,gCAAgC,CAAEA,KAAK,CAAC,CACtD,MACF,CACF,CACF,CACF,CACF,CAAC,CAED;AACA,KAAM,CAAAC,WAAW,CAAI3C,OAAO,EAAK,KAAA4C,eAAA,CAC/B,KAAM,CAAAC,SAAS,CAAG,MAAO,CAAA7C,OAAO,GAAK,QAAQ,CAAGA,OAAO,CAAG8C,IAAI,CAACC,SAAS,CAAC/C,OAAO,CAAC,CACjF,GAAI,EAAA4C,eAAA,CAAA1B,KAAK,CAACe,OAAO,UAAAW,eAAA,iBAAbA,eAAA,CAAeV,UAAU,IAAKC,SAAS,CAACC,IAAI,CAAE,CAChD,GAAI,CACFlB,KAAK,CAACe,OAAO,CAACQ,IAAI,CAACI,SAAS,CAAC,CAC/B,CAAE,MAAOH,KAAK,CAAE,CACdxC,OAAO,CAACwC,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxDnB,eAAe,CAACU,OAAO,CAAClC,OAAO,CAAC8C,SAAS,CAAC,CAC5C,CACF,CAAC,IAAM,CACL3C,OAAO,CAACoC,GAAG,CAAC,sCAAsC,CAAC,CACnDf,eAAe,CAACU,OAAO,CAAClC,OAAO,CAAC8C,SAAS,CAAC,CAC5C,CACF,CAAC,CAED;AACA;AACA,KAAM,CAAAG,OAAO,CAAG5D,WAAW,CAAC,IAAM,CAChC,GAAI,CAAC4B,MAAM,CAAE,CACXd,OAAO,CAACC,IAAI,CAAC,oBAAoB,CAAC,CAClC,OACF,CAEA,KAAM,CAAA8C,KAAK,CAAGzD,QAAQ,CAAC,CAAC,CACxB,GAAI,CAACyD,KAAK,CAAE,CACV/C,OAAO,CAACC,IAAI,CAAC,+BAA+B,CAAC,CAC7CiB,WAAW,CAAC,SAAS,CAAC,CACtB,OACF,CAEA;AACA,KAAM,CAAA8B,KAAK,2BAAAX,MAAA,CAA6BvB,MAAM,YAAAuB,MAAA,CAAUU,KAAK,CAAE,CAC/D/C,OAAO,CAACoC,GAAG,kBAAAC,MAAA,CAAkBW,KAAK,eAAAX,MAAA,CAAajB,oBAAoB,CAACW,OAAO,CAAG,CAAC,KAAG,CAAC,CAEnF,GAAI,CACF,KAAM,CAAAkB,MAAM,CAAG,GAAI,CAAAhB,SAAS,CAACe,KAAK,CAAC,CACnChC,KAAK,CAACe,OAAO,CAAGkB,MAAM,CACtB/B,WAAW,CAAC,YAAY,CAAC,CAEzB+B,MAAM,CAACC,MAAM,CAAG,IAAM,CACpBlD,OAAO,CAACoC,GAAG,CAAC,kCAAkC,CAAC,CAC/ClB,WAAW,CAAC,WAAW,CAAC,CACxBE,oBAAoB,CAACW,OAAO,CAAG,CAAC,CAAE;AAClCoB,UAAU,CAAC,IAAMtB,iBAAiB,CAAC,CAAC,CAAE,GAAG,CAAC,CAC5C,CAAC,CAEDoB,MAAM,CAACG,OAAO,CAAIC,KAAK,EAAK,CAC1BrD,OAAO,CAACoC,GAAG,4BAAAC,MAAA,CAA4BgB,KAAK,CAACC,IAAI,eAAAjB,MAAA,CAAagB,KAAK,CAACE,MAAM,EAAI,oBAAoB,KAAG,CAAC,CACtGrC,WAAW,CAAC,cAAc,CAAC,CAC3BF,KAAK,CAACe,OAAO,CAAG,IAAI,CAEpB;AACA,GAAIX,oBAAoB,CAACW,OAAO,CAAGT,oBAAoB,CAAE,CACvD,KAAM,CAAAkC,KAAK,CAAGhC,iBAAiB,CAACJ,oBAAoB,CAACW,OAAO,CAAC,CAC7DX,oBAAoB,CAACW,OAAO,EAAI,CAAC,CACjC/B,OAAO,CAACoC,GAAG,oBAAAC,MAAA,CAAoBmB,KAAK,oBAAAnB,MAAA,CAAkBjB,oBAAoB,CAACW,OAAO,MAAAM,MAAA,CAAIf,oBAAoB,KAAG,CAAC,CAC9GJ,WAAW,CAAC,cAAc,CAAC,CAC3BC,mBAAmB,CAACY,OAAO,CAAGoB,UAAU,CAAC,IAAM,CAC7CL,OAAO,CAAC,CAAC,CACX,CAAC,CAAEU,KAAK,CAAC,CACX,CAAC,IAAM,CACLxD,OAAO,CAACwC,KAAK,CAAC,6DAA6D,CAAC,CAC5EtB,WAAW,CAAC,OAAO,CAAC,CACpBG,eAAe,CAACU,OAAO,CAACrB,KAAK,CAAC,CAAC,CACjC,CACF,CAAC,CAEDuC,MAAM,CAACQ,OAAO,CAAIjB,KAAK,EAAK,CAC1BxC,OAAO,CAACwC,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjDtB,WAAW,CAAC,OAAO,CAAC,CACtB,CAAC,CACH,CAAE,MAAOsB,KAAK,CAAE,CACdxC,OAAO,CAACwC,KAAK,CAAC,6BAA6B,CAAEA,KAAK,CAAC,CACnDtB,WAAW,CAAC,OAAO,CAAC,CACtB,CACF,CAAC,CAAE,CAACJ,MAAM,CAAC,CAAC,CAAE;AAEd;AACA,KAAM,CAAA4C,SAAS,CAAGA,CAAA,GAAM,CACtB1D,OAAO,CAACoC,GAAG,CAAC,+BAA+B,CAAC,CAC5ChB,oBAAoB,CAACW,OAAO,CAAG,CAAC,CAChC,GAAIZ,mBAAmB,CAACY,OAAO,CAAE,CAC/B4B,YAAY,CAACxC,mBAAmB,CAACY,OAAO,CAAC,CAC3C,CACA,GAAIf,KAAK,CAACe,OAAO,CAAE,CACjBf,KAAK,CAACe,OAAO,CAAC6B,KAAK,CAAC,CAAC,CACvB,CACAd,OAAO,CAAC,CAAC,CACX,CAAC,CAED;AACA,KAAM,CAAAe,cAAc,CAAGA,CAAA,IAAO,CAC5BpD,IAAI,CAAEY,eAAe,CAACU,OAAO,CAACtB,IAAI,CAAC,CAAC,CACpCD,OAAO,CAAEa,eAAe,CAACU,OAAO,CAACvB,OAAO,CAAC,CAC3C,CAAC,CAAC,CAEF;AACAzB,SAAS,CAAC,IAAM,CACd+D,OAAO,CAAC,CAAC,CACT,MAAO,IAAM,CACX9C,OAAO,CAACoC,GAAG,CAAC,kCAAkC,CAAC,CAC/C,GAAIjB,mBAAmB,CAACY,OAAO,CAAE,CAC/B4B,YAAY,CAACxC,mBAAmB,CAACY,OAAO,CAAC,CAC3C,CACA,GAAIf,KAAK,CAACe,OAAO,CAAE,CACjBf,KAAK,CAACe,OAAO,CAAC6B,KAAK,CAAC,CAAC,CACvB,CACA5C,KAAK,CAACe,OAAO,CAAG,IAAI,CACpBb,WAAW,CAAC,cAAc,CAAC,CAC7B,CAAC,CACD;AACF,CAAC,CAAE,CAAC4B,OAAO,CAAC,CAAC,CAEb;AACA;AACA;AACA;AACA;AACA;AACA,mBACE1D,IAAA,CAACC,gBAAgB,CAACyE,QAAQ,EACxBC,KAAK,CAAE,CACL/C,KAAK,CACLC,QAAQ,CACRwB,WAAW,CACXiB,SAAS,CACTG,cACF,CAAE,CAAA9C,QAAA,CAEDA,QAAQ,CACgB,CAAC,CAEhC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}