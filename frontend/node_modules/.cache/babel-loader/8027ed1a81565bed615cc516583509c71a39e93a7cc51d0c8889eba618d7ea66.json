{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useContext, useCallback } from 'react';\nimport { WebSocketContext } from '../../context/WebSocketContext';\n\n/**\r\n * Custom hook for VideoCall component\r\n * Handles WebRTC peer connections and media streams\r\n */\nexport const useVideoCall = (roomId, username) => {\n  _s();\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  const peerConnectionRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const {\n    lastMessage,\n    sendMessage\n  } = useContext(WebSocketContext);\n\n  // WebRTC Configuration\n  const iceServers = {\n    iceServers: [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }]\n  };\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      if (localStreamRef.current) {\n        localStreamRef.current.getTracks().forEach(track => track.stop());\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n    };\n  }, []);\n\n  // Handle receiving WebRTC offer\n  const handleReceiveOffer = useCallback(async offer => {\n    try {\n      if (!peerConnectionRef.current) {\n        // Get local media stream first\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n        localStreamRef.current = stream;\n        if (localVideoRef.current) {\n          localVideoRef.current.srcObject = stream;\n        }\n\n        // Create peer connection\n        peerConnectionRef.current = new RTCPeerConnection(iceServers);\n\n        // Add local stream tracks\n        stream.getTracks().forEach(track => {\n          peerConnectionRef.current.addTrack(track, stream);\n        });\n\n        // Handle remote stream\n        peerConnectionRef.current.ontrack = event => {\n          if (remoteVideoRef.current) {\n            remoteVideoRef.current.srcObject = event.streams[0];\n          }\n        };\n\n        // Handle ICE candidates\n        peerConnectionRef.current.onicecandidate = event => {\n          if (event.candidate && sendMessage) {\n            sendMessage(JSON.stringify({\n              type: 'webrtc-candidate',\n              candidate: event.candidate\n            }));\n          }\n        };\n      }\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await peerConnectionRef.current.createAnswer();\n      await peerConnectionRef.current.setLocalDescription(answer);\n      if (sendMessage) {\n        sendMessage(JSON.stringify({\n          type: 'webrtc-answer',\n          answer: answer\n        }));\n      }\n      setIsCallActive(true);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n    }\n  }, [sendMessage, iceServers]);\n\n  // Handle receiving WebRTC answer\n  const handleReceiveAnswer = useCallback(async answer => {\n    try {\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(answer));\n    } catch (error) {\n      console.error('Error handling answer:', error);\n    }\n  }, []);\n\n  // Handle receiving ICE candidate\n  const handleReceiveCandidate = useCallback(async candidate => {\n    try {\n      await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(candidate));\n    } catch (error) {\n      console.error('Error adding ICE candidate:', error);\n    }\n  }, []);\n\n  // Handle incoming WebRTC signaling messages\n  useEffect(() => {\n    if (!lastMessage || !isCallActive) return;\n    try {\n      const msg = JSON.parse(lastMessage);\n      if (msg.type === 'webrtc-offer') {\n        handleReceiveOffer(msg.offer);\n      } else if (msg.type === 'webrtc-answer') {\n        handleReceiveAnswer(msg.answer);\n      } else if (msg.type === 'webrtc-candidate') {\n        handleReceiveCandidate(msg.candidate);\n      }\n    } catch (error) {\n      console.error('Error handling WebRTC message:', error);\n    }\n  }, [lastMessage, isCallActive, handleReceiveOffer, handleReceiveAnswer, handleReceiveCandidate]);\n  const startCall = async () => {\n    try {\n      // Get local media stream\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n      localStreamRef.current = stream;\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n      }\n\n      // Create peer connection\n      peerConnectionRef.current = new RTCPeerConnection(iceServers);\n\n      // Add local stream tracks to peer connection\n      stream.getTracks().forEach(track => {\n        peerConnectionRef.current.addTrack(track, stream);\n      });\n\n      // Handle remote stream\n      peerConnectionRef.current.ontrack = event => {\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.srcObject = event.streams[0];\n        }\n      };\n\n      // Handle ICE candidates\n      peerConnectionRef.current.onicecandidate = event => {\n        if (event.candidate && sendMessage) {\n          sendMessage(JSON.stringify({\n            type: 'webrtc-candidate',\n            candidate: event.candidate\n          }));\n        }\n      };\n\n      // Create and send offer\n      const offer = await peerConnectionRef.current.createOffer();\n      await peerConnectionRef.current.setLocalDescription(offer);\n      if (sendMessage) {\n        sendMessage(JSON.stringify({\n          type: 'webrtc-offer',\n          offer: offer\n        }));\n      }\n      setIsCallActive(true);\n    } catch (error) {\n      console.error('Error starting call:', error);\n      alert('Failed to start video call. Please check camera/microphone permissions.');\n    }\n  };\n  const toggleMute = () => {\n    if (localStreamRef.current) {\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        setIsMuted(!audioTrack.enabled);\n      }\n    }\n  };\n  const toggleVideo = () => {\n    if (localStreamRef.current) {\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n        setIsVideoOff(!videoTrack.enabled);\n      }\n    }\n  };\n  const endCall = () => {\n    // Stop all tracks\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => track.stop());\n      localStreamRef.current = null;\n    }\n\n    // Close peer connection\n    if (peerConnectionRef.current) {\n      peerConnectionRef.current.close();\n      peerConnectionRef.current = null;\n    }\n\n    // Clear video elements\n    if (localVideoRef.current) {\n      localVideoRef.current.srcObject = null;\n    }\n    if (remoteVideoRef.current) {\n      remoteVideoRef.current.srcObject = null;\n    }\n    setIsCallActive(false);\n    setIsMuted(false);\n    setIsVideoOff(false);\n  };\n  return {\n    localVideoRef,\n    remoteVideoRef,\n    isCallActive,\n    isMuted,\n    isVideoOff,\n    toggleMute,\n    toggleVideo,\n    startCall,\n    endCall\n  };\n};\n_s(useVideoCall, \"sbks5OUPp1KVR8YjxO015Ifean0=\");","map":{"version":3,"names":["useState","useRef","useEffect","useContext","useCallback","WebSocketContext","useVideoCall","roomId","username","_s","isCallActive","setIsCallActive","isMuted","setIsMuted","isVideoOff","setIsVideoOff","localVideoRef","remoteVideoRef","peerConnectionRef","localStreamRef","lastMessage","sendMessage","iceServers","urls","current","getTracks","forEach","track","stop","close","handleReceiveOffer","offer","stream","navigator","mediaDevices","getUserMedia","video","audio","srcObject","RTCPeerConnection","addTrack","ontrack","event","streams","onicecandidate","candidate","JSON","stringify","type","setRemoteDescription","RTCSessionDescription","answer","createAnswer","setLocalDescription","error","console","handleReceiveAnswer","handleReceiveCandidate","addIceCandidate","RTCIceCandidate","msg","parse","startCall","createOffer","alert","toggleMute","audioTrack","getAudioTracks","enabled","toggleVideo","videoTrack","getVideoTracks","endCall"],"sources":["D:/REACT/collaborative-drawing-app/frontend/src/components/VideoCall/VideoCall.hook.js"],"sourcesContent":["import { useState, useRef, useEffect, useContext, useCallback } from 'react';\r\nimport { WebSocketContext } from '../../context/WebSocketContext';\r\n\r\n/**\r\n * Custom hook for VideoCall component\r\n * Handles WebRTC peer connections and media streams\r\n */\r\nexport const useVideoCall = (roomId, username) => {\r\n  const [isCallActive, setIsCallActive] = useState(false);\r\n  const [isMuted, setIsMuted] = useState(false);\r\n  const [isVideoOff, setIsVideoOff] = useState(false);\r\n\r\n  const localVideoRef = useRef(null);\r\n  const remoteVideoRef = useRef(null);\r\n  const peerConnectionRef = useRef(null);\r\n  const localStreamRef = useRef(null);\r\n\r\n  const { lastMessage, sendMessage } = useContext(WebSocketContext);\r\n\r\n  // WebRTC Configuration\r\n  const iceServers = {\r\n    iceServers: [\r\n      { urls: 'stun:stun.l.google.com:19302' },\r\n      { urls: 'stun:stun1.l.google.com:19302' }\r\n    ]\r\n  };\r\n\r\n  // Clean up on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (localStreamRef.current) {\r\n        localStreamRef.current.getTracks().forEach(track => track.stop());\r\n      }\r\n      if (peerConnectionRef.current) {\r\n        peerConnectionRef.current.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Handle receiving WebRTC offer\r\n  const handleReceiveOffer = useCallback(async (offer) => {\r\n    try {\r\n      if (!peerConnectionRef.current) {\r\n        // Get local media stream first\r\n        const stream = await navigator.mediaDevices.getUserMedia({\r\n          video: true,\r\n          audio: true\r\n        });\r\n\r\n        localStreamRef.current = stream;\r\n        if (localVideoRef.current) {\r\n          localVideoRef.current.srcObject = stream;\r\n        }\r\n\r\n        // Create peer connection\r\n        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n\r\n        // Add local stream tracks\r\n        stream.getTracks().forEach(track => {\r\n          peerConnectionRef.current.addTrack(track, stream);\r\n        });\r\n\r\n        // Handle remote stream\r\n        peerConnectionRef.current.ontrack = (event) => {\r\n          if (remoteVideoRef.current) {\r\n            remoteVideoRef.current.srcObject = event.streams[0];\r\n          }\r\n        };\r\n\r\n        // Handle ICE candidates\r\n        peerConnectionRef.current.onicecandidate = (event) => {\r\n          if (event.candidate && sendMessage) {\r\n            sendMessage(JSON.stringify({\r\n              type: 'webrtc-candidate',\r\n              candidate: event.candidate\r\n            }));\r\n          }\r\n        };\r\n      }\r\n\r\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(offer));\r\n      const answer = await peerConnectionRef.current.createAnswer();\r\n      await peerConnectionRef.current.setLocalDescription(answer);\r\n\r\n      if (sendMessage) {\r\n        sendMessage(JSON.stringify({\r\n          type: 'webrtc-answer',\r\n          answer: answer\r\n        }));\r\n      }\r\n\r\n      setIsCallActive(true);\r\n    } catch (error) {\r\n      console.error('Error handling offer:', error);\r\n    }\r\n  }, [sendMessage, iceServers]);\r\n\r\n  // Handle receiving WebRTC answer\r\n  const handleReceiveAnswer = useCallback(async (answer) => {\r\n    try {\r\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(answer));\r\n    } catch (error) {\r\n      console.error('Error handling answer:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Handle receiving ICE candidate\r\n  const handleReceiveCandidate = useCallback(async (candidate) => {\r\n    try {\r\n      await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(candidate));\r\n    } catch (error) {\r\n      console.error('Error adding ICE candidate:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Handle incoming WebRTC signaling messages\r\n  useEffect(() => {\r\n    if (!lastMessage || !isCallActive) return;\r\n\r\n    try {\r\n      const msg = JSON.parse(lastMessage);\r\n\r\n      if (msg.type === 'webrtc-offer') {\r\n        handleReceiveOffer(msg.offer);\r\n      } else if (msg.type === 'webrtc-answer') {\r\n        handleReceiveAnswer(msg.answer);\r\n      } else if (msg.type === 'webrtc-candidate') {\r\n        handleReceiveCandidate(msg.candidate);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebRTC message:', error);\r\n    }\r\n  }, [lastMessage, isCallActive, handleReceiveOffer, handleReceiveAnswer, handleReceiveCandidate]);\r\n\r\n  const startCall = async () => {\r\n    try {\r\n      // Get local media stream\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        video: true,\r\n        audio: true\r\n      });\r\n\r\n      localStreamRef.current = stream;\r\n      if (localVideoRef.current) {\r\n        localVideoRef.current.srcObject = stream;\r\n      }\r\n\r\n      // Create peer connection\r\n      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n\r\n      // Add local stream tracks to peer connection\r\n      stream.getTracks().forEach(track => {\r\n        peerConnectionRef.current.addTrack(track, stream);\r\n      });\r\n\r\n      // Handle remote stream\r\n      peerConnectionRef.current.ontrack = (event) => {\r\n        if (remoteVideoRef.current) {\r\n          remoteVideoRef.current.srcObject = event.streams[0];\r\n        }\r\n      };\r\n\r\n      // Handle ICE candidates\r\n      peerConnectionRef.current.onicecandidate = (event) => {\r\n        if (event.candidate && sendMessage) {\r\n          sendMessage(JSON.stringify({\r\n            type: 'webrtc-candidate',\r\n            candidate: event.candidate\r\n          }));\r\n        }\r\n      };\r\n\r\n      // Create and send offer\r\n      const offer = await peerConnectionRef.current.createOffer();\r\n      await peerConnectionRef.current.setLocalDescription(offer);\r\n\r\n      if (sendMessage) {\r\n        sendMessage(JSON.stringify({\r\n          type: 'webrtc-offer',\r\n          offer: offer\r\n        }));\r\n      }\r\n\r\n      setIsCallActive(true);\r\n    } catch (error) {\r\n      console.error('Error starting call:', error);\r\n      alert('Failed to start video call. Please check camera/microphone permissions.');\r\n    }\r\n  };\r\n\r\n  const toggleMute = () => {\r\n    if (localStreamRef.current) {\r\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\r\n      if (audioTrack) {\r\n        audioTrack.enabled = !audioTrack.enabled;\r\n        setIsMuted(!audioTrack.enabled);\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleVideo = () => {\r\n    if (localStreamRef.current) {\r\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\r\n      if (videoTrack) {\r\n        videoTrack.enabled = !videoTrack.enabled;\r\n        setIsVideoOff(!videoTrack.enabled);\r\n      }\r\n    }\r\n  };\r\n\r\n  const endCall = () => {\r\n    // Stop all tracks\r\n    if (localStreamRef.current) {\r\n      localStreamRef.current.getTracks().forEach(track => track.stop());\r\n      localStreamRef.current = null;\r\n    }\r\n\r\n    // Close peer connection\r\n    if (peerConnectionRef.current) {\r\n      peerConnectionRef.current.close();\r\n      peerConnectionRef.current = null;\r\n    }\r\n\r\n    // Clear video elements\r\n    if (localVideoRef.current) {\r\n      localVideoRef.current.srcObject = null;\r\n    }\r\n    if (remoteVideoRef.current) {\r\n      remoteVideoRef.current.srcObject = null;\r\n    }\r\n\r\n    setIsCallActive(false);\r\n    setIsMuted(false);\r\n    setIsVideoOff(false);\r\n  };\r\n\r\n  return {\r\n    localVideoRef,\r\n    remoteVideoRef,\r\n    isCallActive,\r\n    isMuted,\r\n    isVideoOff,\r\n    toggleMute,\r\n    toggleVideo,\r\n    startCall,\r\n    endCall\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}