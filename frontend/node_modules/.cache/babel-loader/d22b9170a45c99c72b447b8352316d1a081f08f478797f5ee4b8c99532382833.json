{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useContext } from 'react';\nimport { WebSocketContext } from '../../context/WebSocketContext';\n\n/**\r\n * Custom hook for VideoCall component\r\n * Handles WebRTC peer connections and media streams\r\n */\nexport const useVideoCall = (roomId, username) => {\n  _s();\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  const peerConnectionRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const {\n    lastMessage,\n    sendMessage\n  } = useContext(WebSocketContext);\n\n  // WebRTC Configuration\n  const iceServers = {\n    iceServers: [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }]\n  };\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      if (localStreamRef.current) {\n        localStreamRef.current.getTracks().forEach(track => track.stop());\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n    };\n  }, []);\n\n  // Handle incoming WebRTC signaling messages\n  useEffect(() => {\n    if (!lastMessage || !isCallActive) return;\n    try {\n      const msg = JSON.parse(lastMessage);\n      if (msg.type === 'webrtc-offer') {\n        handleReceiveOffer(msg.offer);\n      } else if (msg.type === 'webrtc-answer') {\n        handleReceiveAnswer(msg.answer);\n      } else if (msg.type === 'webrtc-candidate') {\n        handleReceiveCandidate(msg.candidate);\n      }\n    } catch (error) {\n      console.error('Error handling WebRTC message:', error);\n    }\n  }, [lastMessage, isCallActive]);\n  const startCall = async () => {\n    try {\n      // Get local media stream\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n      localStreamRef.current = stream;\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n      }\n\n      // Create peer connection\n      peerConnectionRef.current = new RTCPeerConnection(iceServers);\n\n      // Add local stream tracks to peer connection\n      stream.getTracks().forEach(track => {\n        peerConnectionRef.current.addTrack(track, stream);\n      });\n\n      // Handle remote stream\n      peerConnectionRef.current.ontrack = event => {\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.srcObject = event.streams[0];\n        }\n      };\n\n      // Handle ICE candidates\n      peerConnectionRef.current.onicecandidate = event => {\n        if (event.candidate && sendMessage) {\n          sendMessage(JSON.stringify({\n            type: 'webrtc-candidate',\n            candidate: event.candidate\n          }));\n        }\n      };\n\n      // Create and send offer\n      const offer = await peerConnectionRef.current.createOffer();\n      await peerConnectionRef.current.setLocalDescription(offer);\n      if (sendMessage) {\n        sendMessage(JSON.stringify({\n          type: 'webrtc-offer',\n          offer: offer\n        }));\n      }\n      setIsCallActive(true);\n    } catch (error) {\n      console.error('Error starting call:', error);\n      alert('Failed to start video call. Please check camera/microphone permissions.');\n    }\n  };\n  const handleReceiveOffer = async offer => {\n    try {\n      if (!peerConnectionRef.current) {\n        // Get local media stream first\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n        localStreamRef.current = stream;\n        if (localVideoRef.current) {\n          localVideoRef.current.srcObject = stream;\n        }\n\n        // Create peer connection\n        peerConnectionRef.current = new RTCPeerConnection(iceServers);\n\n        // Add local stream tracks\n        stream.getTracks().forEach(track => {\n          peerConnectionRef.current.addTrack(track, stream);\n        });\n\n        // Handle remote stream\n        peerConnectionRef.current.ontrack = event => {\n          if (remoteVideoRef.current) {\n            remoteVideoRef.current.srcObject = event.streams[0];\n          }\n        };\n\n        // Handle ICE candidates\n        peerConnectionRef.current.onicecandidate = event => {\n          if (event.candidate && sendMessage) {\n            sendMessage(JSON.stringify({\n              type: 'webrtc-candidate',\n              candidate: event.candidate\n            }));\n          }\n        };\n      }\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await peerConnectionRef.current.createAnswer();\n      await peerConnectionRef.current.setLocalDescription(answer);\n      if (sendMessage) {\n        sendMessage(JSON.stringify({\n          type: 'webrtc-answer',\n          answer: answer\n        }));\n      }\n      setIsCallActive(true);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n    }\n  };\n  const handleReceiveAnswer = async answer => {\n    try {\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(answer));\n    } catch (error) {\n      console.error('Error handling answer:', error);\n    }\n  };\n  const handleReceiveCandidate = async candidate => {\n    try {\n      await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(candidate));\n    } catch (error) {\n      console.error('Error adding ICE candidate:', error);\n    }\n  };\n  const toggleMute = () => {\n    if (localStreamRef.current) {\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        setIsMuted(!audioTrack.enabled);\n      }\n    }\n  };\n  const toggleVideo = () => {\n    if (localStreamRef.current) {\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n        setIsVideoOff(!videoTrack.enabled);\n      }\n    }\n  };\n  const endCall = () => {\n    // Stop all tracks\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => track.stop());\n      localStreamRef.current = null;\n    }\n\n    // Close peer connection\n    if (peerConnectionRef.current) {\n      peerConnectionRef.current.close();\n      peerConnectionRef.current = null;\n    }\n\n    // Clear video elements\n    if (localVideoRef.current) {\n      localVideoRef.current.srcObject = null;\n    }\n    if (remoteVideoRef.current) {\n      remoteVideoRef.current.srcObject = null;\n    }\n    setIsCallActive(false);\n    setIsMuted(false);\n    setIsVideoOff(false);\n  };\n  return {\n    localVideoRef,\n    remoteVideoRef,\n    isCallActive,\n    isMuted,\n    isVideoOff,\n    toggleMute,\n    toggleVideo,\n    startCall,\n    endCall\n  };\n};\n_s(useVideoCall, \"BMt0rWb79FmqZ+7Kt/1Pfzupyd8=\");","map":{"version":3,"names":["useState","useRef","useEffect","useContext","WebSocketContext","useVideoCall","roomId","username","_s","isCallActive","setIsCallActive","isMuted","setIsMuted","isVideoOff","setIsVideoOff","localVideoRef","remoteVideoRef","peerConnectionRef","localStreamRef","lastMessage","sendMessage","iceServers","urls","current","getTracks","forEach","track","stop","close","msg","JSON","parse","type","handleReceiveOffer","offer","handleReceiveAnswer","answer","handleReceiveCandidate","candidate","error","console","startCall","stream","navigator","mediaDevices","getUserMedia","video","audio","srcObject","RTCPeerConnection","addTrack","ontrack","event","streams","onicecandidate","stringify","createOffer","setLocalDescription","alert","setRemoteDescription","RTCSessionDescription","createAnswer","addIceCandidate","RTCIceCandidate","toggleMute","audioTrack","getAudioTracks","enabled","toggleVideo","videoTrack","getVideoTracks","endCall"],"sources":["D:/REACT/collaborative-drawing-app/frontend/src/components/VideoCall/VideoCall.hook.js"],"sourcesContent":["import { useState, useRef, useEffect, useContext } from 'react';\r\nimport { WebSocketContext } from '../../context/WebSocketContext';\r\n\r\n/**\r\n * Custom hook for VideoCall component\r\n * Handles WebRTC peer connections and media streams\r\n */\r\nexport const useVideoCall = (roomId, username) => {\r\n  const [isCallActive, setIsCallActive] = useState(false);\r\n  const [isMuted, setIsMuted] = useState(false);\r\n  const [isVideoOff, setIsVideoOff] = useState(false);\r\n\r\n  const localVideoRef = useRef(null);\r\n  const remoteVideoRef = useRef(null);\r\n  const peerConnectionRef = useRef(null);\r\n  const localStreamRef = useRef(null);\r\n\r\n  const { lastMessage, sendMessage } = useContext(WebSocketContext);\r\n\r\n  // WebRTC Configuration\r\n  const iceServers = {\r\n    iceServers: [\r\n      { urls: 'stun:stun.l.google.com:19302' },\r\n      { urls: 'stun:stun1.l.google.com:19302' }\r\n    ]\r\n  };\r\n\r\n  // Clean up on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (localStreamRef.current) {\r\n        localStreamRef.current.getTracks().forEach(track => track.stop());\r\n      }\r\n      if (peerConnectionRef.current) {\r\n        peerConnectionRef.current.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Handle incoming WebRTC signaling messages\r\n  useEffect(() => {\r\n    if (!lastMessage || !isCallActive) return;\r\n\r\n    try {\r\n      const msg = JSON.parse(lastMessage);\r\n\r\n      if (msg.type === 'webrtc-offer') {\r\n        handleReceiveOffer(msg.offer);\r\n      } else if (msg.type === 'webrtc-answer') {\r\n        handleReceiveAnswer(msg.answer);\r\n      } else if (msg.type === 'webrtc-candidate') {\r\n        handleReceiveCandidate(msg.candidate);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling WebRTC message:', error);\r\n    }\r\n  }, [lastMessage, isCallActive]);\r\n\r\n  const startCall = async () => {\r\n    try {\r\n      // Get local media stream\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        video: true,\r\n        audio: true\r\n      });\r\n\r\n      localStreamRef.current = stream;\r\n      if (localVideoRef.current) {\r\n        localVideoRef.current.srcObject = stream;\r\n      }\r\n\r\n      // Create peer connection\r\n      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n\r\n      // Add local stream tracks to peer connection\r\n      stream.getTracks().forEach(track => {\r\n        peerConnectionRef.current.addTrack(track, stream);\r\n      });\r\n\r\n      // Handle remote stream\r\n      peerConnectionRef.current.ontrack = (event) => {\r\n        if (remoteVideoRef.current) {\r\n          remoteVideoRef.current.srcObject = event.streams[0];\r\n        }\r\n      };\r\n\r\n      // Handle ICE candidates\r\n      peerConnectionRef.current.onicecandidate = (event) => {\r\n        if (event.candidate && sendMessage) {\r\n          sendMessage(JSON.stringify({\r\n            type: 'webrtc-candidate',\r\n            candidate: event.candidate\r\n          }));\r\n        }\r\n      };\r\n\r\n      // Create and send offer\r\n      const offer = await peerConnectionRef.current.createOffer();\r\n      await peerConnectionRef.current.setLocalDescription(offer);\r\n\r\n      if (sendMessage) {\r\n        sendMessage(JSON.stringify({\r\n          type: 'webrtc-offer',\r\n          offer: offer\r\n        }));\r\n      }\r\n\r\n      setIsCallActive(true);\r\n    } catch (error) {\r\n      console.error('Error starting call:', error);\r\n      alert('Failed to start video call. Please check camera/microphone permissions.');\r\n    }\r\n  };\r\n\r\n  const handleReceiveOffer = async (offer) => {\r\n    try {\r\n      if (!peerConnectionRef.current) {\r\n        // Get local media stream first\r\n        const stream = await navigator.mediaDevices.getUserMedia({\r\n          video: true,\r\n          audio: true\r\n        });\r\n\r\n        localStreamRef.current = stream;\r\n        if (localVideoRef.current) {\r\n          localVideoRef.current.srcObject = stream;\r\n        }\r\n\r\n        // Create peer connection\r\n        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n\r\n        // Add local stream tracks\r\n        stream.getTracks().forEach(track => {\r\n          peerConnectionRef.current.addTrack(track, stream);\r\n        });\r\n\r\n        // Handle remote stream\r\n        peerConnectionRef.current.ontrack = (event) => {\r\n          if (remoteVideoRef.current) {\r\n            remoteVideoRef.current.srcObject = event.streams[0];\r\n          }\r\n        };\r\n\r\n        // Handle ICE candidates\r\n        peerConnectionRef.current.onicecandidate = (event) => {\r\n          if (event.candidate && sendMessage) {\r\n            sendMessage(JSON.stringify({\r\n              type: 'webrtc-candidate',\r\n              candidate: event.candidate\r\n            }));\r\n          }\r\n        };\r\n      }\r\n\r\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(offer));\r\n      const answer = await peerConnectionRef.current.createAnswer();\r\n      await peerConnectionRef.current.setLocalDescription(answer);\r\n\r\n      if (sendMessage) {\r\n        sendMessage(JSON.stringify({\r\n          type: 'webrtc-answer',\r\n          answer: answer\r\n        }));\r\n      }\r\n\r\n      setIsCallActive(true);\r\n    } catch (error) {\r\n      console.error('Error handling offer:', error);\r\n    }\r\n  };\r\n\r\n  const handleReceiveAnswer = async (answer) => {\r\n    try {\r\n      await peerConnectionRef.current.setRemoteDescription(new RTCSessionDescription(answer));\r\n    } catch (error) {\r\n      console.error('Error handling answer:', error);\r\n    }\r\n  };\r\n\r\n  const handleReceiveCandidate = async (candidate) => {\r\n    try {\r\n      await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(candidate));\r\n    } catch (error) {\r\n      console.error('Error adding ICE candidate:', error);\r\n    }\r\n  };\r\n\r\n  const toggleMute = () => {\r\n    if (localStreamRef.current) {\r\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\r\n      if (audioTrack) {\r\n        audioTrack.enabled = !audioTrack.enabled;\r\n        setIsMuted(!audioTrack.enabled);\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleVideo = () => {\r\n    if (localStreamRef.current) {\r\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\r\n      if (videoTrack) {\r\n        videoTrack.enabled = !videoTrack.enabled;\r\n        setIsVideoOff(!videoTrack.enabled);\r\n      }\r\n    }\r\n  };\r\n\r\n  const endCall = () => {\r\n    // Stop all tracks\r\n    if (localStreamRef.current) {\r\n      localStreamRef.current.getTracks().forEach(track => track.stop());\r\n      localStreamRef.current = null;\r\n    }\r\n\r\n    // Close peer connection\r\n    if (peerConnectionRef.current) {\r\n      peerConnectionRef.current.close();\r\n      peerConnectionRef.current = null;\r\n    }\r\n\r\n    // Clear video elements\r\n    if (localVideoRef.current) {\r\n      localVideoRef.current.srcObject = null;\r\n    }\r\n    if (remoteVideoRef.current) {\r\n      remoteVideoRef.current.srcObject = null;\r\n    }\r\n\r\n    setIsCallActive(false);\r\n    setIsMuted(false);\r\n    setIsVideoOff(false);\r\n  };\r\n\r\n  return {\r\n    localVideoRef,\r\n    remoteVideoRef,\r\n    isCallActive,\r\n    isMuted,\r\n    isVideoOff,\r\n    toggleMute,\r\n    toggleVideo,\r\n    startCall,\r\n    endCall\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}